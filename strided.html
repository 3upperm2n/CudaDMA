<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Cudadma by lightsighter</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="stylesheets/prism.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <script type="text/javascript">
      function fool_bots(domain, naam, term, label) {
        var result = '';
        result += '<a href="' + 'ma' + 'il' + 'to:' + naam;
        result += '@' + domain + '.' + term;
        result += '">' + label + '<' + '/a>';
        document.write(result);
      }
    </script>
    <div class="wrapper">
      <header>
        <a href="index.html"><h1 class="title"><img width=45px" src="logo.jpg">&nbsp&nbspCudaDMA</h1></a>
        <p>Emulating DMA Engines on GPUs for Performance and Portability</p>

        <!-- <p class="view"><a href="https://github.com/lightsighter/CudaDMA">View the Project on GitHub <small>lightsighter/CudaDMA</small></a></p> -->

        <ul>
          <li><a href="https://github.com/lightsighter/CudaDMA">View On <strong>GitHub</strong></a></li>

          <li><a href="https://github.com/lightsighter/CudaDMA/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/lightsighter/CudaDMA/tarball/master">Download <strong>TAR Ball</strong></a></li>
        </ul>
        <p><a href="sc11.pdf">Supercomputing 2011 Paper</a></p>
        <p><a href="starting.html">Getting Started</a></p>
        <p><a href="model.html">Programming Model</a></p>
        <p><a href="object.html">CudaDMA Object API</a></p>
        <p><a href="two.html">Version 2.0</a></p>
        <p><a href="sequential.html">CudaDMA Sequential</a></p>
        <p><a href="strided.html">CudaDMA Strided</a></p>
        <p><a href="indirect.html">CudaDMA Indirect</a></p>
        <p><a href="practices.html">Best Practices</a></p>
        <p><a href="buffering.html">Buffering Techniques</a></p>
        <p><a href="restrictions.html">Restrictions</a></p>
      </header>
      <footer>
        <p>This project is maintained by <a href="https://github.com/lightsighter">lightsighter</a></p>
        <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section>

<h1>
<a id="version-two" class="anchor" href="#version-two" aria-hidden="true"><span class="octicon octicon-link"></span></a>CudaDMAStrided Version 2.0</h1>

<p>CudaDMAStrided <a href="two.html">Version 2.0</a> has the same semantics and is characterized by the same parameters as the original <a href="#version-one">CudaDMAStrided</a>.</p>

<h2>
<a id="constructors-two" class="anchor" href="#constructor-two" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructors</h2>

<p>Constructors support from 3-6 template parameters for the new CudaDMAStrided transfer pattern. All constructors support the new option for specifying the number of <tt>BYTES_PER_THREAD</tt> for outstanding LDG loads. The value of <tt>BYTES_PER_THREAD</tt> must be a multiple of <tt>ALIGNMENT</tt>. By selecting <tt>4*ALIGNMENT</tt> the implementation will default to the Fermi implementation.</p>

<pre><code class="language-cuda">
/* Constructors for use with warp specialization */
CudaDMAStrided&lttrue/*specialized warps*/, ALIGNMENT, 
               BYTES_PER_THREAD, BYTES_PER_ELMT, 
               DMA_THREADS, NUM_ELMTS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start, 
   src_stride, dst_stride);
CudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, DMA_THREADS, NUM_ELMTS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start, 
   src_stride); // dst_stride == src_stride

CudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, DMA_THREADS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride, dst_stride);
CudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, DMA_THREADS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride); // dst_stride == stride

CudaDMAStrided&lttrue, ALIGNMENT, 
               BYTES_PER_THREAD, BYTES_PER_ELMT&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride, dst_stride);
CudaDMAStrided&lttrue, ALIGNMENT, 
               BYTES_PER_THREAD, BYTES_PER_ELMT&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride); // dst_stride == src_stride

CudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_THREAD&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   bytes_per_elmt, num_elmts, src_stride, dst_stride);
CudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_THREAD&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   bytes_per_elmt, num_elmts, src_stride); // dst_stride == src_stride

/* Constructors for use without warp specialization */
CudaDMAStrided&ltfalse/*not specialized*/, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, TOTAL_THREADS, NUM_ELMTS&gt
  (src_stride, dst_stride, dma_threadIdx_start/*optional*/);
CudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, TOTAL_THREADS, NUM_ELMTS&gt
  (src_stride); // dst_stride == src_stride

CudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, TOTAL_THREADS&gt
  (num_elmts, src_stride, dst_stride, dma_threadIdx_start/*optional*/);
CudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_THREAD, 
               BYTES_PER_ELMT, TOTAL_THREADS&gt
  (num_elmts, src_stride); // dst_stride == src_stride

CudaDMAStrided&ltfalse, ALIGNMENT, 
               BYTES_PER_THREAD, BYTES_PER_ELMT&gt
  (num_elmts, src_stride, dst_stride, 
   num_dma_threads/*optional*/, dma_threadIdx_start/*optional*/);
CudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_THREAD, BYTES_PER_ELMT&gt
  (num_elmts, src_stride); // dst_stride == src_stride

CudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_THREAD&gt
  (bytes_per_elmt, num_elmts, src_stride, dst_stride, 
   num_dma_threads/*optional*/, dma_threadIdx_start/*optional*/);
CudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_THREAD&gt
  (bytes_per_elmt, num_elmts, src_stride); // dst_stride == src_stride
</code></pre>

<p>Unlike previous versions of CudaDMA, the non-warp-specialized implementations also allow you to specify that a subset of the available warps should be used. These are optional parameters. Not specifying them will default to using all the threads in a threadblock for the transfer.</p>

<h2>
<a id="transfer-two" class="anchor" href="#transfer-two" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transfer Functions</h2>

<p>CudaDMAStrided supports the following transfer functions.</p>

<pre><code class="language-cuda">
class CudaDMAStrided {
public:
  // One-Phase Versions
  __device__ void execute_dma(const void *src_ptr, void *dst_ptr);

  template&ltbool GLOBAL_LOAD&gt
  __device__ void execute_dma(const void *src_ptr, void *dst_ptr);

  template&ltbool GLOBAL_LOAD, CudaDMALoadQualifier LOAD_QUAL, 
           CudaDMAStoreQual STORE_QUAL&gt
  __device__ void execute_dma(const void *src_ptr, void *dst_ptr);

  // Two-Phase Versions
  __device__ void start_xfer_async(const void *src_ptr);

  template&ltbool GLOBAL_LOAD&gt
  __device__ void start_xfer_async(const void *src_ptr);

  template&ltbool GLOBAL_LOAD, CudaDMALoadQualifier LOAD_QUAL, 
           CudaDMAStoreQual STORE_QUAL&gt
  __device__ void start_xfer_async(const void *src_ptr);

  __device__ void wait_xfer_finish(void *dst_ptr);

  template&ltbool GLOBAL_LOAD&gt
  __device__ void wait_xfer_finish(void *dst_ptr);

  template&ltbool GLOBAL_LOAD, CudaDMALoadQualifier LOAD_QUAL, 
           CudaDMAStoreQual STORE_QUAL&gt
  __device__ void wait_xfer_finish(void *dst_ptr);
};
</code></pre>

<h2>
<a id="diagnostic-two" class="anchor" href="#diagnostic-two" aria-hidden="true"><span class="octicon octicon-link"></span></a>Diagnostic Functions</h2>

<p>CudaDMAStrided implements the following host-side diagnostic function. It should be invoked with no template parameters.</p>

<pre><code class="language-cuda">
template<...>
class CudaDMAStrided
{
public:
  __host__ static 
  void diagnose(int alignment, int bytes_per_thread, 
                int bytes_per_elmt, int num_dma_threads, 
                int num_elements, bool fully_templated, 
                bool verbose = false);
};

// Example invocation
CudaDMAStridedi&lt&gt::(/*arguments*/);
</code></pre>

<h1>
<a id="version-one" class="anchor" href="#version-one" aria-hidden="true"><span class="octicon octicon-link"></span></a>CudaDMAStrided Version 1.0</h1>

<h2>
<a id="pattern-one" class="anchor" href="#pattern-one" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pattern Description</h2>

<p>The CudaDMAStrided pattern is used for transferring multiple blocks of data that are evenly spaced apart in memory. Every block of memory must be of the same size. We refer to these blocks of memory as elements.</p>

<p>The CudaDMAStrided pattern can be characterized by five different parameters.</p>

<ul>
  <li><tt>ALIGNMENT</tt> - byte alignment of all elements (e.g. 4-,8-, or 16-byte aligned)</li>
  <li><tt>ALIGNMENT</tt> - byte alignment of all elements (e.g. 4-,8-, or 16-byte aligned)</li>
  <li><tt>NUM_ELMTS</tt> - the number of elements to be transfered</li>
  <li><tt>src_stride</tt> - the stride between the source elements in bytes</li>
  <li><tt>dst_stride</tt> - the stride between elements after they have been transferred in bytes</li>
</ul>

<p>Both stride parameters are from the start of one element to the start of the next element. The destination stride must be at least as large as <tt>BYTES_PER_ELMT</tt> or else the behavior of the transfer is undefined. Also, the <tt>ALIGNMENT</tt> parameter must apply to be the source and destination locations of every element. This implies that both <tt>src_stride</tt> and <tt>dst_stride</tt> must be divisible by the <tt>ALIGNMENT</tt> parameter.</p>

<h2>
<a id="constructors-one" class="anchor" href="#constructors-one" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructors</h2>

<p>The CudaDMAStrided pattern can be instantiated by a variety of constructors that allow different parameters to be passed as compile-time constants via template parameters. In addition, there are are special constructors for the common case where the destination stride is equal to size of the elements. Models for each of the different constructors for the CudaDMAStrided pattern can be seen below.</p>

<pre><code class="language-cuda">
/* Constructors for use with warp specialization */
cudaDMAStrided&lttrue/*specialized warps*/, ALIGNMENT, 
               BYTES_PER_ELMT, DMA_THREADS, NUM_ELMTS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start, 
   src_stride, dst_stride);
cudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_ELMT, 
               DMA_THREADS, NUM_ELMTS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start, 
   src_stride); // dst_stride == BYTES_PER_ELMT

cudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_ELMT, DMA_THREADS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride, dst_stride);
cudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_ELMT, DMA_THREADS&gt
  (dmaID, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride); // dst_stride == BYTES_PER_ELMT

cudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_ELMT&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride, dst_stride);
cudaDMAStrided&lttrue, ALIGNMENT, BYTES_PER_ELMT&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   num_elmts, src_stride); // dst_stride == BYTES_PER_ELMT

cudaDMAStrided&lttrue, ALIGNMENT&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   bytes_per_elmt, num_elmts, src_stride, dst_stride);
cudaDMAStrided&lttrue, ALIGNMENT&gt
  (dmaID, num_dma_threads, num_compute_threads, dma_threadIdx_start,
   bytes_per_elmt, num_elmts, 
   src_stride); // dst_stride == BYTES_PER_ELMT

/* Constructors for use without warp specialization */
cudaDMAStrided&ltfalse/*not specialized*/, ALIGNMENT, 
               BYTES_PER_ELMT, TOTAL_THREADS, NUM_ELMTS&gt
  (src_stride, dst_stride);
cudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_ELMT, 
               TOTAL_THREADS, NUM_ELMTS&gt
  (src_stride); // dst_stride == BYTES_PER_ELMT

cudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_ELMT, TOTAL_THREADS&gt
  (num_elmts, src_stride, dst_stride);
cudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_ELMT, TOTAL_THREADS&gt
  (num_elmts, src_stride); // dst_stride == BYTES_PER_ELMT

cudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_ELMT&gt
  (num_elmts, src_stride, dst_stride);
cudaDMAStrided&ltfalse, ALIGNMENT, BYTES_PER_ELMT&gt
  (num_elmts, src_stride); // dst_stride == BYTES_PER_ELMT

cudaDMAStrided&ltfalse, ALIGNMENT&gt
  (bytes_per_elmt, num_elmts, src_stride, dst_stride);
cudaDMAStrided&ltfalse, ALIGNMENT&gt
  (bytes_per_elmt, num_elmts, 
   src_stride); // dst_stride == BYTES_PER_ELMT
</code></pre>

<p>Each constructor takes the base set of CudaDMA object arguments required by the <a href="object.html">CudaDMA API</a>. In addition, each constructor takes the set of arguments required to fully characterize the CudaDMAStrided transfer pattern.</p>

<p>For the non-warp-specialized constructors, the total threads parameter describes the total number of threads to be used to perform the transfer. In the cases where total threads is not supplied as a compile-time constant, the number of threads defaults to <tt>blockDim.x</tt>. This is only true for the non-warp-specialized case.</p>

<h2>
<a id="performance-one" class="anchor" href="#performance-one" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance Considerations</h2>

<p>The highest possible performance for CudaDMAStrided pattern will be achieved when as many arguments as possible are specified as compile-time constants. It's important to note that the number of DMA threads is more important as a compile-time constant than the number of elements to be transferred. Higher performance can also be achieved by ensuring larger alignment of the elements. 16-byte alignment will perform better than 8-byte alignment, and 8-byte alignment will perform better than 4-byte alignment.</p>

      </section> 
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-20524102-4");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
    <script src="javascripts/prism.js"></script> 
  </body>
</html>
